// Global KiddoVerse namespace
var KV = KV || {};
KV.World = class World { constructor(scene,blockSize,theme){this.scene=scene;this.blockSize=blockSize;this.theme=theme;this.chunkSize=16;this.chunks={};this.chunkMeshes=new THREE.Group();this.scene.add(this.chunkMeshes);this.noise=new KV.Noise(Date.now()+Math.random()*1000);this.renderDistance=3;this.verticalRenderDistance=2;this.lastPlayerChunkX=null;this.lastPlayerChunkY=null;this.lastPlayerChunkZ=null;this.maxChunksToKeep=(this.renderDistance*2+3)*(this.renderDistance*2+3)*(this.verticalRenderDistance*2+3);this.chunkUnloadDelay=30000;this.maxRebuildsPerFrame=2;} async generateInitialChunks(playerPos){console.log(`KV Themes: Generating initial world chunks for theme: ${this.theme.name}`);const pCX=Math.floor(playerPos.x/(this.chunkSize*this.blockSize));const pCY=Math.floor(playerPos.y/(this.chunkSize*this.blockSize));const pCZ=Math.floor(playerPos.z/(this.chunkSize*this.blockSize));this.lastPlayerChunkX=pCX;this.lastPlayerChunkY=pCY;this.lastPlayerChunkZ=pCZ;await this.loadUnloadChunks(pCX,pCY,pCZ,true);console.log("KV Themes: Initial chunks generated.");} getChunkKey(cX,cY,cZ){return `${cX},${cY},${cZ}`;} generateChunkData(chunkX,chunkY,chunkZ){const chunkData=new Uint8Array(this.chunkSize*this.chunkSize*this.chunkSize);const themeParams=this.theme.terrainParams;for(let lx=0;lx<this.chunkSize;lx++){for(let lz=0;lz<this.chunkSize;lz++){const worldX=chunkX*this.chunkSize+lx;const worldZ=chunkZ*this.chunkSize+lz;const heightNoise=this.noise.simplex2(worldX*themeParams.noiseScaleXZ,worldZ*themeParams.noiseScaleXZ);const surfaceY=Math.floor(themeParams.baseHeight+heightNoise*themeParams.amplitude);for(let ly=0;ly<this.chunkSize;ly++){const worldY=chunkY*this.chunkSize+ly;const index=ly*this.chunkSize*this.chunkSize+lz*this.chunkSize+lx;let blockType=KV.BLOCK_TYPES.AIR;if(worldY<surfaceY-themeParams.stoneDepth){blockType=themeParams.blockPalette.deepStone||KV.BLOCK_TYPES.STONE;}else if(worldY<surfaceY){blockType=themeParams.blockPalette.subSurface||KV.BLOCK_TYPES.DIRT;}else if(worldY===surfaceY){blockType=themeParams.blockPalette.surface||KV.BLOCK_TYPES.GRASS;} chunkData[index]=blockType;}}} return chunkData;} async ensureChunk(cX,cY,cZ){const key=this.getChunkKey(cX,cY,cZ);if(!this.chunks[key]){const chunkData=this.generateChunkData(cX,cY,cZ);this.chunks[key]={x:cX,y:cY,z:cZ,data:chunkData,mesh:null,needsUpdate:true,lastAccessed:Date.now(),isGeneratingMesh:false};}else{this.chunks[key].lastAccessed=Date.now();} return this.chunks[key];} getBlock(wX,wY,wZ){const cX=Math.floor(wX/this.blockSize/this.chunkSize);const cY=Math.floor(wY/this.blockSize/this.chunkSize);const cZ=Math.floor(wZ/this.blockSize/this.chunkSize);const lx=Math.floor(wX/this.blockSize)-cX*this.chunkSize;const ly=Math.floor(wY/this.blockSize)-cY*this.chunkSize;const lz=Math.floor(wZ/this.blockSize)-cZ*this.chunkSize;const key=this.getChunkKey(cX,cY,cZ);const chunk=this.chunks[key];if(!chunk||lx<0||lx>=this.chunkSize||ly<0||ly>=this.chunkSize||lz<0||lz>=this.chunkSize){return KV.BLOCK_TYPES.AIR;}const index=ly*this.chunkSize*this.chunkSize+lz*this.chunkSize+lx;return chunk.data[index];} setBlock(wX,wY,wZ,blockType){const bX=Math.floor(wX/this.blockSize);const bY=Math.floor(wY/this.blockSize);const bZ=Math.floor(wZ/this.blockSize);const cX=Math.floor(bX/this.chunkSize);const cY=Math.floor(bY/this.chunkSize);const cZ=Math.floor(bZ/this.chunkSize);const lx=bX-cX*this.chunkSize;const ly=bY-cY*this.chunkSize;const lz=bZ-cZ*this.chunkSize;this.ensureChunk(cX,cY,cZ).then(chunk=>{if(chunk){this.setBlockInternal(chunk,lx,ly,lz,blockType);}else{console.error(`Failed to ensure chunk for setBlock.`);}}); } setBlockInternal(chunk,lX,lY,lZ,type){if(lX<0||lX>=this.chunkSize||lY<0||lY>=this.chunkSize||lZ<0||lZ>=this.chunkSize){return;}const index=lY*this.chunkSize*this.chunkSize+lZ*this.chunkSize+lX;if(chunk.data[index]===type)return;chunk.data[index]=type;chunk.needsUpdate=true;const checkN=(ox,oy,oz)=>{const nk=this.getChunkKey(chunk.x+ox,chunk.y+oy,chunk.z+oz);const nc=this.chunks[nk];if(nc)nc.needsUpdate=true;};if(lX===0)checkN(-1,0,0);if(lX===this.chunkSize-1)checkN(1,0,0);if(lY===0)checkN(0,-1,0);if(lY===this.chunkSize-1)checkN(0,1,0);if(lZ===0)checkN(0,0,-1);if(lZ===this.chunkSize-1)checkN(0,0,1);} buildChunkMesh(chunk){if(chunk.isGeneratingMesh)return;chunk.isGeneratingMesh=true;if(chunk.mesh){this.chunkMeshes.remove(chunk.mesh);chunk.mesh.geometry.dispose();}chunk.mesh=null;const pos=[],norm=[],uvs=[],idx=[],matGrp=[];let curIdx=0;const mats=[];const matMap=new Map();const hS=this.blockSize/2;const cOX=chunk.x*this.chunkSize*this.blockSize;const cOY=chunk.y*this.chunkSize*this.blockSize;const cOZ=chunk.z*this.chunkSize*this.blockSize;for(let ly=0;ly<this.chunkSize;ly++){for(let lz=0;lz<this.chunkSize;lz++){for(let lx=0;lx<this.chunkSize;lx++){const bT=chunk.data[ly*this.chunkSize*this.chunkSize+lz*this.chunkSize+lx];if(bT===KV.BLOCK_TYPES.AIR)continue;const bD=KV.BLOCK_DEFINITIONS[bT];if(!bD)continue;const wBX=chunk.x*this.chunkSize+lx;const wBY=chunk.y*this.chunkSize+ly;const wBZ=chunk.z*this.chunkSize+lz;const isNTA=(nbx,nby,nbz)=>{const nbt=this.getBlock(nbx*this.blockSize,nby*this.blockSize,nbz*this.blockSize);if(nbt===KV.BLOCK_TYPES.AIR)return true;const nd=KV.BLOCK_DEFINITIONS[nbt];return nd&&nd.transparent;};const p=[[-hS,-hS,-hS],[+hS,-hS,-hS],[+hS,+hS,-hS],[-hS,+hS,-hS],[-hS,-hS,+hS],[+hS,-hS,+hS],[+hS,+hS,+hS],[-hS,+hS,+hS]];const bcX=lx*this.blockSize+hS;const bcY=ly*this.blockSize+hS;const bcZ=lz*this.blockSize+hS;const faceData=[{n:[1,0,0],v:[1,5,6,2],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.side||bD.textures.all},{n:[-1,0,0],v:[4,0,3,7],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.side||bD.textures.all},{n:[0,1,0],v:[3,2,6,7],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.top||bD.textures.all},{n:[0,-1,0],v:[0,4,5,1],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.bottom||bD.textures.all},{n:[0,0,1],v:[5,4,7,6],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.side||bD.textures.all},{n:[0,0,-1],v:[0,1,2,3],uv:[[0,0],[1,0],[1,1],[0,1]],tk:bD.textures.side||bD.textures.all}];for(const face of faceData){if(isNTA(wBX+face.n[0],wBY+face.n[1],wBZ+face.n[2])){let matKey=face.tk;let matIdx=matMap.get(matKey);if(matIdx===undefined){const threeMat=KV.getBlockMaterial(matKey,bD);mats.push(threeMat);matIdx=mats.length-1;matMap.set(matKey,matIdx);}for(let i=0;i<4;i++){const v=p[face.v[i]];pos.push(bcX+v[0],bcY+v[1],bcZ+v[2]);norm.push(...face.n);uvs.push(...face.uv[i]);}idx.push(curIdx,curIdx+1,curIdx+2,curIdx,curIdx+2,curIdx+3);let curGrp=matGrp.length>0?matGrp[matGrp.length-1]:null;if(!curGrp||curGrp.materialIndex!==matIdx){matGrp.push({start:idx.length-6,count:6,materialIndex:matIdx});}else{curGrp.count+=6;}curIdx+=4;}}}}}}if(idx.length>0){const geom=new THREE.BufferGeometry();geom.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));geom.setAttribute('normal',new THREE.Float32BufferAttribute(norm,3));geom.setAttribute('uv',new THREE.Float32BufferAttribute(uvs,2));geom.setIndex(idx);for(const grp of matGrp){geom.addGroup(grp.start,grp.count,grp.materialIndex);}geom.computeBoundingSphere();const cMesh=new THREE.Mesh(geom,mats);cMesh.position.set(cOX,cOY,cOZ);cMesh.castShadow=true;cMesh.receiveShadow=true;chunk.mesh=cMesh;this.chunkMeshes.add(cMesh);}chunk.needsUpdate=false;chunk.isGeneratingMesh=false;} update(pPos){const pCX=Math.floor(pPos.x/(this.chunkSize*this.blockSize));const pCY=Math.floor(pPos.y/(this.chunkSize*this.blockSize));const pCZ=Math.floor(pPos.z/(this.chunkSize*this.blockSize));if(pCX!==this.lastPlayerChunkX||pCY!==this.lastPlayerChunkY||pCZ!==this.lastPlayerChunkZ){this.loadUnloadChunks(pCX,pCY,pCZ);this.lastPlayerChunkX=pCX;this.lastPlayerChunkY=pCY;this.lastPlayerChunkZ=pCZ;}let rebuilt=0;for(const key in this.chunks){if(rebuilt>=this.maxRebuildsPerFrame)break;const chunk=this.chunks[key];if(chunk.needsUpdate&&!chunk.isGeneratingMesh){this.buildChunkMesh(chunk);rebuilt++;}}} async loadUnloadChunks(ccX,ccY,ccZ,initLoad=false){const newCProms=[];const activeCK=new Set();const lR=this.renderDistance;const vLR=this.verticalRenderDistance;for(let dx=-lR;dx<=lR;dx++){for(let dz=-lR;dz<=lR;dz++){for(let dy=-vLR;dy<=vLR;dy++){const cX=ccX+dx;const cY=ccY+dy;const cZ=ccZ+dz;const key=this.getChunkKey(cX,cY,cZ);activeCK.add(key);if(!this.chunks[key]){newCProms.push(this.ensureChunk(cX,cY,cZ));}else{this.chunks[key].lastAccessed=Date.now();}}}}if(newCProms.length>0){await Promise.all(newCProms);}if(Object.keys(this.chunks).length>this.maxChunksToKeep){const sorted=Object.values(this.chunks).sort((a,b)=>a.lastAccessed-b.lastAccessed);let removed=0;for(const chunk of sorted){if(Object.keys(this.chunks).length-removed<=this.maxChunksToKeep)break;const key=this.getChunkKey(chunk.x,chunk.y,chunk.z);if(!activeCK.has(key)&&(Date.now()-chunk.lastAccessed>this.chunkUnloadDelay)){if(chunk.mesh){this.chunkMeshes.remove(chunk.mesh);chunk.mesh.geometry.dispose();}delete this.chunks[key];removed++;}}}};
console.log("KiddoVerse Themes: World class updated for themes.");
